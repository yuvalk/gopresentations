How to train your gophers

Yuval Kashtan
Red Hat
@yuvalk
yuvalkashtan@gmail.com
yuval@redhat.com

[[https://github.com/yuvalk/howtotrainyourgophers][_this_ _presentation_]] _was_ _written_ _in_ _go_

Presentation inspired and derived from `[[https://github.com/fedepaol/howtotrainyourgophers][How to train your gophers]]` by the great [[@fedepaol][Federico Paolinelli]]

* About me

- Red Hatter
- Telco 5G Engineering, Security Team Lead
- Infrastructure Developer (Networking, Storage, Security, etc)
- All things opensource


* Agenda

Not an Intro to Go
- Multiprocessing recap
- Brief history of multithreading
- Go Routines
- Go

* Multiprocessing recap

* What is Process
.image process.png 250 _
ready queue
.image process-queues.png 200 _
: A process is an instance of a program that is being executed.
: 

* What is a Thread
.image process-vs-thread.png
"lightweight" process, managed independently by the scheduler.

* Concurrent vs Parallel
.image concurrent_vs_parallel.png

* Brief history of multithreading

.image multithreading.jpeg 350 _
.caption image from playembbeded.com

* multi processing

.code multiprocess.c /START OMIT/,/END OMIT/
$ time ./mproc 

real	0m1.433s

: written in C, because there is no (easy) go equivalency 

* multi threading

.code multithread.c /START OMIT/,/END OMIT/
$time ./mthread

real 0m0.582s

: threads are faster, less context switch overhead

* goroutines

.play goroutines.go /START OMIT/,/END OMIT/
$ time go run goroutine.go 
Customer: ordered pizza

real	0m0.216s

* Where are my gophers?!

.image beergophers.png 400 _

: A bug in multithreading can result in memory corruption with unexpected and unpredictable results. Moreover, it could happen in very rare situations difficult to reproduce with tests.
: What's more, a wrong usage of the locking primitives can result in a deadlock of two or more threads.
: *Getting*threading*right*is*difficult*

* Goroutines

Goroutines are lightweight threads managed by the Go runtime.

	go myFunction()

*Why*lighter?*

- smaller (altough variable) stack
- many goroutines can share a single os thread
- scheduling not invoked periodically but as a consequence of synchronization


_It_is_practical_to_create_hundreds_of_thousands_of_goroutines_in_the_same_address_space_


* Why are they different?

* Mile per Gallon
[[https://github.com/golang/go/blob/master/src/runtime/proc.go#L22][src/runtime/proc.go]]:
.code proc.go /START OMIT/,/END OMIT/
Each goroutine (G) runs on an OS thread (M) that is assgined to a logical CPU (P)

* Channels

A channel is a communication mechanism between two goroutines

	ch := make(chan int)

We can send values to a channel

	ch <- 23

or receive from a channel

	res := <- ch

or just check if send has happened

	<- ch

* Buffered vs unbuffered

Channels can be buffered or unbuffered.

	buffered := make(chan int, 5)

	unbuffered := make(chan int)

Sending on a full channel blocks the sender, receiving from an empty channel blocks the receiver.

: channels are VALUES
: origins in csp communicating sequential processes

* Goroutines are indipendent executing actors communicating via channels
.image concurrency.jpeg

Definetely easier to reason about

* Select

	select {
	case <-ch1:
		// ...
	case x := <-ch2:
		// ...use x...
	case ch3 <- y:
		// ...
	default:
		// ...
	}

A way to multiplex several channels. Waits until a communication for one of its cases is ready.

* Classic synchronization primitves

- Mutexes
- RW Locks
- sync.Once
- Atomic operations (atomic package)


* Let's put this into the real world

* A simple goroutine 

.image simple.png 300 _

* A simple goroutine 

.play -edit goroutine.go /START OMIT/,/END OMIT/

* With synchronization

.image simplewithsync.png 300 _

* With synchronization 

.play syncgoroutine.go /START OMIT/,/END OMIT/

* Select multiplexes multiple channels

.image select.png 350 _

* Select multiplexes multiple channels

.play selectgoroutine.go /START OMIT/,/END OMIT/

: Risultato omesso per far vedere solo come funziona la select sui canli
: La select e' pseudorandom se tutti i case sono non bloccanti
: generator lancia una goroutine e ritorna un canale su cui la goroutine scrive

* Closing a channel generates a message

.image range.png 400 _

* Closing a channel generates a message

.play closechannel.go /START OMIT/,/END OMIT/

: Per vedere se un canale si chiude si guarda secondo valore restituito

* Closing a channel generates a message (short version)

.play closechannelwithrange.go /START OMIT/,/END OMIT/

* Some patterns

* Block with timeout

.image selecttimeout.png 300 _

* Block with timeout

.play selecttimeout.go /START OMIT/,/END OMIT/

: funziona perche' i canali non piu` raggiungibili vengono portati via dal gc

* Fan in

.image fanin.png 400 _

* Fan in

.play fanin.go /START OMIT/,/END OMIT/

* Load balancer with workers

.image loadbalancer.png 400 _

* Load balancer with workers

.play loadbalancer.go /START OMIT/,/END OMIT/

* Channels can be passed around

.image channelpassed.png 400 _

* Channels can be passed around

.play channelspassed.go /START OMIT/,/END OMIT/

: pattern simile a async await

* .. and more 

* What can we say about goroutines

- Goroutines are actors that perform their tasks sequentially
- No mutexes, no locks, no callbacks!
- Fun to write!
- A way to transform a sequential program into a concurreny one

* The last gopher trainer advice(s)

* Handle with care!

- avoid the temptation to summon your gopher army
- context switch has an hidden cost
- mutexes / rw locks have their use cases
- use the profilers
- use the synchronization primitives and the atomic package

: non sono la soluzione a tutti i mali
: le mappe si proteggono molto meglio con un rw lock che non passando da una goroutine


* Where to go from here

- Official website
.link http://golang.org

- Interactive Tutorial
.link http://tour.golang.org

- Go dev
.link https://go.dev

- Effective go
.link https://golang.org/doc/effective_go.html

- Mailing list
.link https://groups.google.com/forum/#!forum/golang-nuts

