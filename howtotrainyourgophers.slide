How to train your gophers

Yuval Kashtan
Red Hat
@yuvalk
yuvalkashtan@gmail.com
yuval@redhat.com

[[https://github.com/yuvalk/howtotrainyourgophers][_this_ _presentation_]] _was_ _written_ _in_ _go_

Presentation inspired and derived from `[[https://github.com/fedepaol/howtotrainyourgophers][How to train your gophers]]` by the great [[@fedepaol][Federico Paolinelli]]

* About me
- Telco 5G Platform Engineering, Security Team Lead @ Red Hat
- Infrastructure Developer (Networking, Storage, Security, etc)
- Past work with many startups. Partial list: TriSixtySecurity, Qumranet, Correlsense, Cellepathy, Robo-Team, Aqua Security, XtremIO, Elastifile, PomVom, and others.
- All things opensource


* Agenda
Not an Intro to Go
- Why Go
- Multiprocessing recap
- Brief history of multithreading
- Go Routines
- Go

* Why Go
.image Go-Logo_Black.png 400 _
.caption from [[https://blog.golang.org/go-brand][The go branding strategy]]
: Very popular
: one of the only 4 dev languages allowed @ Google (others are: Python, c/c++ and Java)
: the most interesting things released in the last period are done in go

* Why Go
.image companiesusing.png 400 _
.caption from [[https://go.dev][go.dev]]
: crossing the chasm

* The recipe for Go
- Go back to the 70s / 80s and find a bunch of great programmers. Say, Ken Thompson, Rob Pike, people like that. Marinate them in Bell Labs for 30 years, during which time they code in C, keep developing Unix, invent Plan 9, UTF-8, and other wonderful things.
- Take them out, seduce them with Python, wow them with Google-scale computing. Add more amazing programmers (Brad Fitzpatrick for example), stir in Googleâ€™s near-unlimited resources.
- Ask them how they would do C now, if they could start from scratch.
.caption _credits_ by [[https://www.darkcoding.net/software/go-lang-after-four-months/][Graham King]]

* Can a language be fast and fun to use?
.image gograph.png 400 _

* Go's elevator pitch:
- fast
- good at networking and multiprocessing
- scales well
- easy to learn
- comprehensible

* Go vs lower level languages
gVisor was written in Go in order to avoid security pitfalls that can plague kernels. With Go, there are strong types, built-in bounds checks, no uninitialized variables, no use-after-free, no stack overflow, and a built-in race detector. (The use of Go has its challenges too, and isn't free.)
.caption from [[https://github.com/google/gvisor][google gvisor repository]]

* Multiprocessing recap

* What is Process
.image process.png 250 _
ready queue
.image process-queues.png 200 _
: A process is an instance of a program that is being executed.

* What is a Thread
.image process-vs-thread.png
"lightweight" process, managed independently by the scheduler.

* Concurrent vs Parallel
.image concurrent_vs_parallel.png

* Brief history of multithreading
.image multithreading.jpeg 350 _
.caption image from playembbeded.com

* multi processing
.code multiprocess.c /START OMIT/,/END OMIT/
$ time ./mproc 

real	0m1.433s
: written in C, because there is no (easy) go equivalency 

* multi threading
.code multithread.c /START OMIT/,/END OMIT/
$time ./mthread

real 0m0.582s
: threads are faster, less context switch overhead

* goroutines
.play goroutines.go /START OMIT/,/END OMIT/
$ time go run goroutine.go 
Customer: ordered pizza

real	0m0.216s

* Where are my gophers?!
.image beergophers.png 400 _
: A bug in multithreading can result in memory corruption with unexpected and unpredictable results. Moreover, it could happen in very rare situations difficult to reproduce with tests.
: What's more, a wrong usage of the locking primitives can result in a deadlock of two or more threads.
: *Getting*threading*right*is*difficult*

* A minute for Hebrew speakers
.image gopher.jpg 350 _
Pocket gophers, commonly referred to simply as gophers, are burrowing rodents of the family Geomyidae.[2] The roughly 41 species[3] are all endemic to North and Central America.[4] They are commonly known for their extensive tunneling activities and their ability to destroy farms and gardens. 
[[https://en.wikipedia.org/wiki/Gopher][wikipedia - Gopher]]

* Goroutines
Goroutines are lightweight threads managed by the Go runtime.

	go myFunction()

*Why*lighter?*

- smaller (altough variable) stack
- many goroutines can share a single os thread
- scheduling not invoked periodically but as a consequence of synchronization

_It_is_practical_to_create_hundreds_of_thousands_of_goroutines_in_the_same_address_space_

* Example
.play goroutine_intro.go /START OMIT/,/END OMIT/


* Why are they different?

* Mile per Gallon
[[https://github.com/golang/go/blob/master/src/runtime/proc.go#L22][src/runtime/proc.go]]:
.code proc.go /START OMIT/,/END OMIT/
Each goroutine (G) runs on an OS thread (M) that is assgined to a logical CPU (P)

