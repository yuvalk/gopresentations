How to train your gophers

Yuval Kashtan
Red Hat
@yuvalk
yuvalkashtan@gmail.com
yuval@redhat.com

[[https://github.com/yuvalk/howtotrainyourgophers][_this_ _presentation_]] _was_ _written_ _in_ _go_

Presentation inspired and derived from `[[https://github.com/fedepaol/howtotrainyourgophers][How to train your gophers]]` by the great [[@fedepaol][Federico Paolinelli]]

* About me
- Telco 5G Platform Engineering, Security Team Lead @ Red Hat
- Infrastructure Developer (Networking, Storage, Security, etc)
- Past work with many startups. Partial list: TriSixtySecurity, Qumranet, Correlsense, Cellepathy, Robo-Team, Aqua Security, XtremIO, Elastifile, PomVom, and others.
- All things opensource


* Agenda
Not an Intro to Go
- Multiprocessing recap
- Brief history of multithreading
- Go Routines
- Go

* Multiprocessing recap

* What is Process
.image process.png 250 _
ready queue
.image process-queues.png 200 _
: A process is an instance of a program that is being executed.

* What is a Thread
.image process-vs-thread.png
"lightweight" process, managed independently by the scheduler.

* Concurrent vs Parallel
.image concurrent_vs_parallel.png

* Brief history of multithreading
.image multithreading.jpeg 350 _
.caption image from playembbeded.com

* multi processing
.code multiprocess.c /START OMIT/,/END OMIT/
$ time ./mproc 

real	0m1.433s
: written in C, because there is no (easy) go equivalency 

* multi threading
.code multithread.c /START OMIT/,/END OMIT/
$time ./mthread

real 0m0.582s
: threads are faster, less context switch overhead

* goroutines
.play goroutines.go /START OMIT/,/END OMIT/
$ time go run goroutine.go 
Customer: ordered pizza

real	0m0.216s

* Where are my gophers?!
.image beergophers.png 400 _
: A bug in multithreading can result in memory corruption with unexpected and unpredictable results. Moreover, it could happen in very rare situations difficult to reproduce with tests.
: What's more, a wrong usage of the locking primitives can result in a deadlock of two or more threads.
: *Getting*threading*right*is*difficult*

* Goroutines
Goroutines are lightweight threads managed by the Go runtime.

	go myFunction()

*Why*lighter?*

- smaller (altough variable) stack
- many goroutines can share a single os thread
- scheduling not invoked periodically but as a consequence of synchronization


_It_is_practical_to_create_hundreds_of_thousands_of_goroutines_in_the_same_address_space_


* Why are they different?

* Mile per Gallon
[[https://github.com/golang/go/blob/master/src/runtime/proc.go#L22][src/runtime/proc.go]]:
.code proc.go /START OMIT/,/END OMIT/
Each goroutine (G) runs on an OS thread (M) that is assgined to a logical CPU (P)

